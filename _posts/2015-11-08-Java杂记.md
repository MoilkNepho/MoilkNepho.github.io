---
layout: post
title: Java杂记
tags:  [Java,编程语言]
categories: [Java]
author: Moilk
excerpt: "学习Java过程中一些零碎的笔记"
---

1）在子类覆盖超类的方法时，子类方法不能低于超类方法的可见性，这是为了保证父类指针能引用子类的方法；

2）java中，抽象类不能被实例化，但可以定义一个抽象类的对象变量，让它去引用非抽象子类的对象；   
3）Java中用于控制可见性的4个访问修饰符：

  * 仅对本类可见--private；
  * 对所有类可见--public；
  * 对本包和所有子类可见--protected；
  * 对本包可见--默认，即没有表明任何修饰符的情况，这是一种不太受欢迎的形式；

4）完美equal方法的建议：

  * 显示参数命名为otherobject，稍后需要将它转换成另一个叫做other的变量；
  * 检测this和other是否引用同一个对象；

```java
if(this == otherObject) return ture; 
```

  * 检测otherobject是否为null，如果为null，返回false

```java
if(otherObject == null) return false; 
```

  * 比较this与otherObject是否为同一类。如果equal的语义在每一个子类中有所改变，就使用getClass检测：

```java
if(getClass() != otherObjecr.getClass()) return false; 
```

如果所有子类都拥有同一语义，就使用instanceof检测：

```java
 if(!(otherObject instanceof ClassName)) return false; 
```

  * 将otherObject转换为相应的类类型变量：

```java
ClassName other = (ClassName) otherObject; 
```

  * 现在开始对所有需要比较的域进行比较了。使用==比较基本类型域；使用equals比较对象域。如果所有的域都匹配，就返回true，否则返回false。

```java
return field1 == other.field1
    && field2.equal(other.field2)
    && ...;
```

如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。

**警告：** equals要覆盖Object类的equals方法。 

4） toString：

  * 只要对象与一个字符串通过操作符“+”连接起来，java编译就会自动调用toString方法，一遍获得这个对象的字符串描述 ；
  * 数组的toString要通过调用静态方法Array.toString（多维数组调用Array.deepToString)修正以生成字符串。
  * 建议为自己定义的每一个类增加一个toString方法。

5） 泛型数组列表 ArrayList：

  * void set(int index,T obj) 设置数组列表指定位置的元素值，覆盖原有内容；
  * T get(int index) 获得指定位置的元素值；
  * void add(int index,T obj) 向后移动元素，以便插入元素；
  * T remove(int index) 删除指定位置元素并返回，将后面的元素向前移动；

6） 对象包装器：

  * int intValue() 以int的形式返回Integer对象的值；
  * static String toString(int i) 以一个新String对象的形式返回给定数值i的十进制表示；
  * static String toString(int i,int radix) 返回数值i的基于给定radix参数进制的表示；
  * static String toString(String s) 返回字符串s表示的整型数值（十进制）；
  * static String toString(String s,int radix) 返回字符串s表示的整型数值（radix进制）；
  * static Integer valueOf(String s) 返回用s表示的整型数值进行初始化后的一个新的Integer对象；
  * static Integer valueOf(String s,int radix) 返回用s表示的整型数值进行初始化后的一个新的Integer对象（radix进制）
  * Number parse(String s) 返回s表示的数字值；

7） 枚举类：

  * static Enum valueOf(Class enumClass,String name) 返回指定名字、给定类的枚举常量；
  * String toString() 返回枚举常量名；
  * int ordinal() 返回枚举常量在enum声明中的位置，位置从0开始计数；
  * int compareTo(E other) 如果枚举变量出现在other之前，则返回一个负值；如果this==other，则返回0；否则，返回正值。枚举变量的出现次序在enum声明中给出。

8） Class类：

  * 获得Class类对象的三种方法： 
    * Class cl=e.getClass();
    * Class cl=Class.forName(className);
    * Class cl=T.class; //T为任意的java类型，如int、Date和Employee等
  * 虚拟机为，每个类型管理一个Class对象。因此可以利用==运算符实现两个类型对象的比较操作，如： `if(e.getClass() == Employee.class) ...`
  * newInstance(): 
    * **说明：**newInstance方法调用没有参数的构造器，如果没有这样的构造器，则会抛出异常。
    
```java
    e.getClass().newInstance();     //创建了一个与e具有相同类型的实例 
    Class.forName(str).newInstance()    //按名称str的类名创建对象 
```

9） 利用反射分析类：

  * java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。
  * 三个类都有getName()用来返回项目的名称；
  * 三个类都有getModifier()，它将返回一个整型数值，用不同的位开关描述public和static这样的修饰符的使用情况。另外还可以使用Modifier类中的toString()、isPublic()、isPrivate()或isFinal()这样的方法分析；
  * Constructor和Method类中有一个getParameterTypes方法，以数组的形式返回构造器中参数的类型(Class对象)；
  * Method类中还有一个getReturnType()方法，以数组的形式返回方法的返回类型(Class对象);
  * Class类中有getFields()、getMethod()和getConstructor()方法，分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员；
  * Class类中还有getDeclareFields()、getDeclareMethod()和getDeclareConstructors()方法，返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包含超类成员；
  * Class类中getName()方法返回项目名称(String)；
  * Class类中还有getType()方法返回项目类型(Class对象)；

10） 接口：[interface详解(from cdsn)](http://blog.csdn.net/zdwzzu2006/article/details/4567957)
